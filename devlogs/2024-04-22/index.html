<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/basic.css"> <link rel=icon  href="/assets/favicon.png"> <title>devlog 2024-04-22, the case for a julia graph database</title> <header> <div class=blog-name > <span style="font-size: medium;">this is the</span> <a href="/">co</a>mind <span style="font-size: medium;">blog</span> <br/> </div> <!-- <nav> <ul> <li><a href="/">Home</a> <li><a href="/menu1/">Code blocks</a> <li><a href="/menu2/">More goodies</a> <li><a href="/menu3/">Tags</a> </ul> <img src="/assets/hamburger.svg" id=menu-icon > </nav> --> </header> <div class=franklin-content ><h1 id=devlog_2024-04-22_the_case_for_a_julia_graph_database ><a href="#devlog_2024-04-22_the_case_for_a_julia_graph_database" class=header-anchor >devlog 2024-04-22, the case for a julia graph database</a></h1> <p>One of the nice things about comind is that it is a platform where I get to experiment with random ideas. Comind is still a passion project, so I kind of get to do whatever interests me. </p> <p>This evening, I did a fun little dive into what a <a href="https://twitter.com/cameron_pfiffer/status/1782623115560046611">graph database</a> might look like in Julia. Comind currently uses Postgres, but it&#39;s not really the easiest to use. Maybe there&#39;s a cool Julia database to be made&#33;</p> <p>A few great graph database products exist already &#40;like <a href="https://neo4j.com/">Neo4j</a>, <a href="https://aws.amazon.com/neptune/">Amazon Neptune</a>, <a href="https://gremlin.apache.org/">Gremlin</a>&#41;, but I think there&#39;s something to be had in the Julia ecosystem, and in particular, one for Comind specifically. </p> <p><a href="https://en.wikipedia.org/wiki/Graph_database">Graph databases</a> are a type of database that stores information in a particular way – as nodes and edges. Nodes are &quot;entitites&quot;, like people, companies, information, etc. Edges are the relationships between these entities: Alice and Bob know each other, so we have an edge from Alice to Bob. </p> <p>Graph databases work really well when you need to traverse relationships between nodes. For example, if you want to see who you could ask Bob to connect Alice to, you can traverse Alice -&gt; Bob and see who is connected to Bob. In a standard relational database like postgres or any of the other members of the innumerate hordes of RDBMS, you would have to do something like a <code>JOIN</code> to get this information. Joins <a href="https://stackoverflow.com/questions/173726/when-and-why-are-database-joins-expensive">can be</a> expensive &#40;but not always&#33;&#41;. Graph databases make doing lots of &quot;hops&quot; between nodes very fast, which might require many joins in the case of a relational database.</p> <p>Comind could use something like a graph database. Basically everything in comind is a &quot;thought&quot;, which is some kind of post or content from a user. We&#39;re going to have a lot of these &#40;with any luck&#41;.</p> <p>Thoughts are <strong>linked</strong> to one another by users. Each time you add a new thought, add a thought to your meld, or someone else adds a thought to a meld you are in, you are linking two thoughts together. It is the core, fundamental action in Comind to link thoughts.</p> <p>The second part of this that makes a graph database useful is that all of comind is intended to be accessed regularly, easily, and safely &#40;in a privacy sense&#41; by generative AI models. </p> <p>A graph database could help manage &quot;knowledge&quot; available to language models when and where they need to have information. The way that people currently provide context to language models is by using retrieval-augmented generation &#40;RAG&#41; produced with semantic search.</p> <p>The process for this is</p> <ol> <li><p>The user asks a query, &quot;what color is the sky?&quot;</p> <li><p>We get the <a href="https://quantumblack.medium.com/embeddings-the-language-of-llms-and-genai-b74c2bef105a">embedding</a> for that query, some vector <code>Q</code>.</p> <li><p>We then take the cosine similarity of <code>Q</code> with all the embeddings in our graph database. This gives you a score from 0 to 1, with 1 meaning &quot;more similar to this&quot;, and 0 meaning &quot;not at all similar to this&quot;.</p> <li><p>We return these results and pack the most related ones into the language model context window.</p> </ol> <p>Note that this is super expensive. For each new query <code>Q</code>, we have to compute the cosine similarity of <code>Q</code> with all the embeddings in our graph database. This is a lot of computations for each new query. If you have billions of records, this is an ass-load of compute.</p> <p>Fortunately, we have lots of vector databases for this kind of thing. <a href="https://www.pinecone.io/">Pinecone</a>, arguably the loudest vector DB at the moment, does what is called &quot;approximate nearest neighbors&quot; search. This involves &quot;clumping&quot; similar embedding vectors together. Then, when you have a new query, you only search over something like the &quot;average&quot; of that clump. This is a lot more efficient than a full search through your entire database. It&#39;s also a simplification, but you get the gist.</p> <p>I think we can do better, at least for Comind&#39;s use case. Let&#39;s take a simple example, where we want to show the user a &quot;start page&quot; thought. This is kind of a vague idea I&#39;ve had where I show you some LLM commentary about what you&#39;ve been thinking about recently. </p> <ol> <li><p>The user logs on.</p> <li><p>We retrieve the user&#39;s <code>n</code> most recent thoughts, as well as the <code>k&#43;1</code> &quot;hops&quot; around those thoughts &#40;i.e. for A -&gt; B -&gt; C, C is two hops from A&#41;.</p> <li><p>We perform semantic search for RAG on <em>only</em> the neighoring thoughts.</p> </ol> <p>Boom. That&#39;s fast as fuck, at least way faster than a full search through your entire database, and probably more precise and relevant than approximate nearest neighbor.</p> <p>So, Julia. I use Julia a lot. It is my favorite language. All the backend for Comind is in Julia. Why not a Julia database, and why not one custom-rolled for Comind&#39;s link-based embedding search?</p> <p>Plus, adding various plugins to the database to do graph neural networks using <a href="https://github.com/CarloLucibello/GraphNeuralNetworks.jl">GraphNeuralNetworks.jl</a> would be a breeze, since the entire ecosystem is consolidated around <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a>. We could keep everything self contained and extensible in the only the way Julia can be.</p> <p>And for parallelism, stuff like <a href="https://github.com/JuliaParallel/Dagger.jl">Dagger.jl</a> could be extremely cool for the storage engine/query engine. </p> <p>Importantly, the database could also be completely GPU-enabled relatively easily&#33; The whole JuliaGPU ecosystem is incredibly good. I haven&#39;t thought too hard about that but man would it be cool as fuck.</p> <p>Anyway – fun to speculate. Did a little tinkering but mostly reading tonight.</p> <p>– Cameron</p> <h2 id=the_work_i_actually_did ><a href="#the_work_i_actually_did" class=header-anchor >the work i actually did</a></h2> <ul> <li><p>Lots of UI overhauls to the web interface</p> <li><p>Debugging some dumb fucking stuff</p> </ul> <h2 id=references ><a href="#references" class=header-anchor >References</a></h2> <ul> <li><p>https://dgraph.io/blog/post/why-google-needed-graph-serving-system/</p> </ul> <div class=page-foot > mindco © thanks to <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">Julia</a>. <br/> </div> </div>