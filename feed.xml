<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  The Comind Blog  ]]>
    </title>
    <link> https://blog.comind.me/ </link>
    <description>
      <![CDATA[  trying to think good thoughts  ]]>
    </description>
    <atom:link
      href="https://blog.comind.me/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  devlog 2024-05-24  ]]>
  </title>
  <link> https://blog.comind.me/devlogs/2024-05-24/index.html </link>
  <guid> https://blog.comind.me/devlogs/2024-05-24/index.html </guid>
  <description>
    <![CDATA[  been a hot minute  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="devlog_2024-05-24">devlog 2024-05-24</h1>
<p>Wow, been a long time since my last devlog. It&#39;s been a weird few weeks, with some misc poor moods, lots of evening/weekend events. My actual job at Stanford has also been a lot recently.</p>
<p>Anyway – I thought I&#39;d do a whole-ass overview of what&#39;s been going on and what&#39;s changed.</p>
<h2 id="product">Product</h2>
<ul>
<li><p>I sat down and figured out the entire API the server needs to provide, what tools the front-end needs to be able to handle, and basically how all of comind is supposed to work as a product. I&#39;ll be writing this up over the next few days thought it will sadly be internal for the moment.</p>
</li>
<li><p>It&#39;ll be nice to sit down and work through each of the API points. There are a handful of people in a Telegram channel with me who are vaguely interested in the project – some of them have offered to help, but I have been extraordinarily bad at project management and making Comind a hospitable environment for new contributors. </p>
</li>
<li><p>Hopefully, building a clear, concise design document for the backend will help me get other folks involved to the extent that they are interested.</p>
</li>
<li><p>The product for comind is a server and an API, and the company will provide an open-source front-end for public use and development. Later on, we&#39;ll provide a paid-for commercial front-end that&#39;s not dissimilar from Slack on growth hormones.</p>
</li>
<li><p>I am occasionally annoyed at how long it has taken me to appreciate the benefit of completing a <strong>complete plan</strong> for a product. I don&#39;t think I could have done anything different, since all my fucking around thusfar has been extremely helpful for me understanding exactly what I want comind to be.</p>
</li>
<li><p>Time to get serious and get shit out the door. This is a good product.</p>
</li>
</ul>
<h2 id="backend">Backend</h2>
<ul>
<li><p>Lots of tinkering with graph database stuff and kind of just hating all the tools that exist. It will surprise nobody that the API support in Julia for various graph databases like Neo4j, TigerGraph, TerminusDB, etc. are either broken to shit or completely non-existent.</p>
</li>
<li><p>I ended up writing an entire Julia package for property graphs &#40;PropertyGraphs.jl&#41; that supports pattern matching queries, with the eventual goal of producing an industrial-grade graph system for Comind&#39;s internal usage. The work was heavily inspired by <a href="https://github.com/JuliaComputing/SQLiteGraph.jl">SQLiteGraph.jl</a>, an incredibly simple package.</p>
</li>
</ul>
<pre><code class="language-julia">using PropertyGraphs# Set up some nodes
john &#61; Node&#40;1, &quot;person&quot;, &quot;human&quot;; name&#61;&quot;John Doe&quot;, age&#61;25&#41;
jane &#61; Node&#40;2, &quot;person&quot;, &quot;human&quot;; name&#61;&quot;Jane Doe&quot;, age&#61;26&#41;# Set up some edges
john_jane &#61; Edge&#40;1, 2, &quot;friend of&quot;; since&#61;2010&#41;
jane_john &#61; Edge&#40;2, 1, &quot;friend of&quot;; since&#61;2011&#41;
husband &#61; Edge&#40;1, 2, &quot;husband of&quot;; since&#61;1992&#41;
wife &#61; Edge&#40;2, 1, &quot;wife of&quot;; since&#61;1992&#41;# Make the graph
graph &#61; PropertyGraph&#40;
      Node&#91;john, jane&#93;, 
      Edge&#91;john_jane, jane_john, husband, wife&#93;
&#41;# Perform a match query to get all &quot;human&quot; nodes,
# returns a new graph with john and jane.
match&#40;graph, NodePattern&#40;&quot;person&quot;, &quot;human&quot;&#41;&#41;# returns just john
match&#40;graph, NodePattern&#40;name&#61;&quot;John Doe&quot;&#41;&#41;# Matching edges is similar, this returns a graph with 
# just the &quot;friend of&quot; edges
match&#40;
      graph, 
      EdgePattern&#40;&quot;friend of&quot;&#41;
&#41;# You can also provide an arbitrary number of patterns to 
# match on. For example, this will return a graph with
# john and jane, as well as the husband/wife edges
# between them.
match&#40;
      graph,
      NodePattern&#40;name&#61;&quot;John Doe&quot;&#41;,
      NodePattern&#40;name&#61;&quot;Jane Doe&quot;&#41;,
      EdgePattern&#40;&quot;husband of&quot;&#41;,
      EdgePattern&#40;&quot;wife of&quot;&#41;,
&#41;</code></pre>
<ul>
<li><p>It was fun to write this, and it came together very quickly. It sadly does not implement the Graphs.jl abstract graph interface &#40;yet&#41; as there was some overhead I just wasn&#39;t willing to deal with for a prototype package.</p>
</li>
<li><p>Eventually, PropertyGraphs.jl will sit on top of postgres and will be easily loaded/saved to disk, and the comind server will essentially just be running a large, in-memory graph DB. Over time the plan is to add tooling for distributed graph processing.</p>
</li>
</ul>
<h2 id="frontend">Frontend</h2>
<ul>
<li><p>The frontend has come a long way. The design is simple and clean, though lacking a lot of features.</p>
</li>
</ul>
<p><img src="https://blog.comind.me/assets/2024-05-24/main-page.png" alt="The main page" /> <img src="https://blog.comind.me/assets/2024-05-24/short-page.png" alt="The main page, narrow" /></p>
<ul>
<li><p>You can also talk to people on it in melds. My friend Grace and I had our first conversation on Comind a few days ago – it was broken as hell, you had to refresh the page to see new messages – but it <strong>worked</strong>. Fuckin incredible.</p>
</li>
<li><p>There are publicly accessible melds, the first of which is the void cafe:</p>
</li>
</ul>
<p><img src="https://blog.comind.me/assets/2024-05-24/void-cafe.png" alt="The void cafe" /></p>
<ul>
<li><p>I did a massive overhaul to how the front-end handles suggestions &#40;thoughts you might want to think about&#41;. Now, there&#39;s a little &quot;think&quot; button in the bottom right that will show you thoughts that are related:</p>
</li>
</ul>
<p><img src="https://blog.comind.me/assets/2024-05-24/thought-bubble.png" alt="A thought bubble" /></p>
<ul>
<li><p>Pressing the think button currently does <a href="https://en.wikipedia.org/wiki/Semantic_search">semantic search</a> to show you related thoughts, but we&#39;re working on the recommender system to show you more relevant thoughts that include graph information, popularity, recency, etc.</p>
</li>
<li><p>Things I like about the design     - It&#39;s simple and clean     - It has a minimalistic design     - It&#39;s unobtrusive</p>
</li>
<li><p>Things I don&#39;t like about the design     - It takes up too much screen real estate     - It&#39;s slow and doesn&#39;t feel &quot;snappy&quot;     - It&#39;s not the most mobile friendly</p>
</li>
</ul>
<h2 id="misc">Misc</h2>
<p>Life has been very much in the way lately. I&#39;ve been able to do some work on comind here and there but I&#39;ve been quite burned out from work and I often feel like I need a break. The nights and weekends thing I&#39;ve been doing is fun and all, but it has been very difficult to juggle having a job, trying to exercise regularly, and spending time with people I love.</p>
<p>At the same time, I&#39;m also looking for work as my postdoctoral contract ends relatively soon. Sadly, I do not have the financial resources to take a vacation of any kind, otherwise I would <em>happily</em> take off several months to work on comind. The days when I have a full workday are absolutely <em>insane</em> – I end up accomplishing the same amount of work in a day that I do over an entire week of nights &amp; weekends.</p>
<p>Anyway. Looking forward to more stuff. I am delighted with the property graph stuff, and I&#39;m happy I was able to sit down and hand-write the entire business down. Feels good to have a plan.</p>
<p>– Cameron</p>
 ]]>
  </content:encoded>
    
  <pubDate>Fri, 24 May 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>mindco</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  devlog 2024-05-09  ]]>
  </title>
  <link> https://blog.comind.me/devlogs/2024-05-09/index.html </link>
  <guid> https://blog.comind.me/devlogs/2024-05-09/index.html </guid>
  <description>
    <![CDATA[  communal thinking tools  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="devlog_2024-05-09_communal_thinking_tools">devlog 2024-05-09, communal thinking tools</h1>
<ul>
<li><p>Wrote a big-ass <a href="https://twitter.com/cameron_pfiffer/status/1788791693619425715">X thread</a>. I copied the tweets below.</p>
</li>
<li><p>Started permitting suggestions being attributed to specific thoughts in a meld. </p>
</li>
<li><p>A <em>suggestion</em> is a set of related thoughts that you may choose to introduce into your meld. </p>
</li>
<li><p>Suggestions may be related content, something novel from a language model, another meld, etc.</p>
</li>
<li><p>There&#39;s an issue with how I&#39;ve been doing them. I&#39;ve been sending all thoughts in a bucket &#40;A, B, C&#41; and then just getting a bulk suggestion for all the items, rather than produce a set of suggestions for <em>each</em> thought.</p>
</li>
<li><p>So, started laying the ground work on the client side to handle this. Thoughts now have &quot;space&quot; underneath them for suggestions, and the core code to handle that for different melds is now also working.</p>
</li>
<li><p>Here&#39;s a rough sketch of what this vaguely looks like:</p>
</li>
</ul>
<pre><code class="language-julia">╭────────────────────────────────╮
│  A thought                     │
╰────────────────────────────────╯      - A suggestions -╭────────────────────────────────╮
│  B thought                     │
╰────────────────────────────────╯      - B suggestions -</code></pre>
<p>I&#39;m tired as fuck. Sprinted up the steep part of Telegraph Hill today with my backpack and also I guess I don&#39;t sleep anymore.</p>
<p>– Cameron</p>
<h2 id="the_x_thread">the x thread</h2>
<p><a href="https://twitter.com/cameron_pfiffer/status/1788791693619425715">&#40;source&#41;</a></p>
<p>I wanted to talk about comind, and what I think the future of social platforms, AI, and knowledge management.</p>
<p>Let communal thinking tools 🧵</p>
<p>I spend a lot of time thinking about this. Walking. Running. Going to bed. Waking up. Showering. Eating. Sitting on the train. Talking. Basically all the time.</p>
<p>I might be pretty close to an expert in the space for that reason, especially because it is very small right now.</p>
<p>Comind and another, Subsconcious &#40;noosphere&#41;, are part of this emerging system of organizing, sharing, permissioning, and exposing simple text for the explicit purpose of using AI to communicate, learn, and organize information.</p>
<p>The idea behind these tools seems to be making personal knowledge sharable in a collaborative setting. </p>
<p>Like the World Wide Web, but more restrictive – no HTML or ugly token-heavy content. </p>
<p>Just text. Why?</p>
<p>Because language is how we communicate extraordinarily complicated ideas. You and I can talk right now on a computer that humans built because they were able to talk, to build on millennia of learning.</p>
<p>Language is valuable. It is how we store the entirety of the real-world&#39;s information, it is how we transmit useful information, learn, evolve, discover, etc.</p>
<p>Communal thinking tools should index that knowledge in a simple, human &#43; machine-readable structure. Papers, tweets, SMS, your emails, web pages, etc. </p>
<p>All of this stuff is clunky and spread all over the place. Thinking tools put this in a box that a robot helps you understand.</p>
<p>Something I am now learning is that lots of people are starting to think about the exact same things as I have been thinking about for nearly a year now. I&#39;ve heard this from people on multiple projects, and people I have just randomly met.</p>
<p>And what that thing is a new way for humans and generative models to interact. Something like a public square where we all communicate and learn with one another, and where machines can do the same.</p>
<p>Basically, a big shared brain.</p>
<p>I can see a version of the future where we have many, many tiny agents, all of whom are going to need to access some kind of information to do their jobs. </p>
<p>They need an API for this, or something very cheap to use. Something clean and simple. At the same time, this platform is not going to be useful if it doesn&#39;t have people on it. </p>
<p>So, the obvious fix here is just to put everything in one bucket, make sure information goes where people want it to go, handle privacy, etc. in a clean way.</p>
<p>People will use this stuff for day-to-day things. Shopping lists. Booking flights. Messaging.</p>
<p>And also for big things. Research too – you could just write a paper into your communal thought pool. Elicit is starting this path already. Very cool product.</p>
<p>There&#39;s two outcomes here and it really depends on how things evolve.</p>
<ol>
<li><p>There will be a monopoly. A single platform that handles everyone&#39;s thoughts and resembles google.</p>
</li>
<li><p>Fierce, specialized competition not unlike the web of the 90s and early 00s.</p>
</li>
</ol>
<p>Comind is targeting the consumer social angle – how do you do the social and learning part?</p>
<p>Subconcious is tackling the &quot;how&quot; part – how do you actually make a massive-scale, open P2P comms layer?</p>
<p>Elicit is tackling the deep, focused research part. It&#39;ll be weird seeing these evolve, because people are going to use them. </p>
<p>Communal thinking tools are useful and interesting, and it&#39;ll get rid of a lot of shit we don&#39;t need &#40;emails/slack/a million texting apps&#41;.</p>
<p>I&#39;m not really an e/acc person, I&#39;m not really an AI doomer. I&#39;m sort of both – I think there&#39;s an amazing future for AI stuff in our world, but also great risk, and I think it&#39;s wise to be careful.</p>
<p>That said, general artificial intelligence is probably right around the corner.  It is weird to say that, but it&#39;s true – and I&#39;m not the only person working on this stuff. I think it has legs.</p>
<p>Who else is doing it? Subsconcious is the big one someone pointed out to me.</p>
<p>@co<em>mind</em>co has kind of a &#40;very cool&#41; competitor in the distributed protocol for thought called Subsconcious. It&#39;s been stressing me out and I&#39;m struggling with motivation due to it.</p>
<p>https://subconscious.network</p>
<p>On blue place, Paul &#40;atproto dev at bsky&#41; has this helpful comment: The nice thing here is that I am product-focused. I want people to have a simple, clean app that can be nimble because it is not a protocol. I can just change things as needed. So, thanks Paul.</p>
<p>&#91;&#91;image omitted&#93;&#93;</p>
<p>Seeing others think about this stuff is good because I know that something like comind will have legs. </p>
<p>However, it is also bad, because that thing may not be comind.</p>
<p>It is difficult to have a direct competitor, especially because I can look over at their &#40;moderately large&#41; Discord and see what&#39;s going on. The engineers are really seasoned engineers with a lot of technical chops.</p>
<p>They have thought really deeply and clearly about how to do P2P correctly, which is sort of a long-term goal of comind&#39;s.</p>
<p>They also have a cool little app demo in the discord &#40;really loved it&#41; that is upsettingly familiar to my general design. It kind of shook me a little because they have a person who is actually a front-end engineer, while I am an overextended hack.</p>
<p>Kind of weird to be back in imposter-syndrome land. </p>
<p>But&#33; I should probably try to keep in mind that I only work on comind because I absolutely fucking love it. If it flops, if I get beat out, whatever, got to fuck around in this tiny nascent space that I suspect will be large.</p>
 ]]>
  </content:encoded>
    
  <pubDate>Thu, 09 May 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>mindco</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  devlog 2024-05-04  ]]>
  </title>
  <link> https://blog.comind.me/devlogs/2024-05-04/index.html </link>
  <guid> https://blog.comind.me/devlogs/2024-05-04/index.html </guid>
  <description>
    <![CDATA[  bits, bytes, etc.  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="devlog_2024-05-04_bit-representations_for_graph_vertices">devlog 2024-05-04, bit-representations for graph vertices</h1>
<p>Lots of fun stuff today&#33; It was rainy for a lot of the morning after my regatta, so I managed to cozy up and do some programming without getting too much sunshine-FOMO.</p>
<p>In the evening I did actual comind work, and the first part of the day was mostly fucking around with bit-representations for graph databases. I&#39;ll do the comind stuff first and then a brief recap of the graph database work.</p>
<h2 id="comind_work">comind work</h2>
<p>I&#39;m adding an endpoint to the server called <code>examine</code>. When you <code>examine</code> a thought, it is a way focusing your attention on a particular piece of content to uncover more information about it.Examinations are essentially detail views of thoughts. </p>
<p>There&#39;s a few ways I&#39;m imagining this working. Examinations should show you</p>
<ol>
<li><p>Directly linked thoughts, i.e. parents, children, replies, etc.</p>
</li>
<li><p>A brief description of the surrouding context, i.e. &quot;your friends saw this and have been discussing why you would say something so stupid, in a loving way&quot;. </p>
</li>
<li><p>Suggested thoughts that are not linked but seem to be related.</p>
</li>
</ol>
<p>I have &#40;1&#41; done, &#40;3&#41; is easy enough but not done, and &#40;2&#41; is where I spent most of the evening.</p>
<p>It turns out that contextualizing a &quot;web&quot; of thoughts for language models is not super easy, at least not from a prompt engineering side. I&#39;ve settled for beginning to specify a text format for describing general context and relationships between thoughts.</p>
<p>When you <code>examine</code> a thought, I go and pull the &quot;neighborhood&quot; of thoughts surrouding your primary thought within some nmber of hops. For example, if I pulled in all thoughts within two hops of <code>A</code> and was looking at a link chain <code>A -&gt; B -&gt; C -&gt; D</code>, I would pull in <code>A</code>, <code>B</code>, and <code>C</code>. </p>
<p>Then, I need to dump the content of each of those thoughts into a query to provide to the language model. The way this is starting to form is to provide the language model a new comind-specific markup language that feels very 1970.</p>
<p>Thoughts are wrapped in <em>blocks</em> that include some variables describing interrelationships and annotating specific content.</p>
<p>Here is the block for the <strong>primary thought</strong>. When you <code>examine</code> a thought, you are making that thought &quot;primary&quot;.</p>
<p>Here&#39;s something I might write, and how it is rendered in the context prompt:</p>
<pre><code class="language-julia">&lt;BEGIN PRIMARY THOUGHT BY&#61;cameron&gt;
here&#39;s some notes i wrote about language models
&lt;END PRIMARY THOUGHT&gt;</code></pre>
<p>Within the same prompt, you can optionally include <em>context</em> thoughts that the language model is instructed to review only if relevant to the primary thought. If the thought is in the neighborhood, a <code>HOPS&#61;&#91;number&#93;</code> field is included to suggest to the model that it is more likely to be relevant.</p>
<pre><code class="language-julia">&lt;BEGIN THOUGHT HOPS&#61;1 BY&#61;cameron&gt;
language models tend to hallucinate, so it&#39;s important to provide context that is relevant to the primary thought.
&lt;END THOUGHT&gt;</code></pre>
<p>Your context window would basically be as full as possible of related thoughts, and then I leave it up to the model to determine what is most relevant for the answer. To determine what I actually want from the model, I found it to help by adding a <code>REQUEST</code> block:</p>
<pre><code class="language-julia">&lt;BEGIN REQUEST&gt;
can you please tell me what i know about language models?
&lt;END REQUEST&gt;</code></pre>
<p>This whole thing is vaguely hacky, but ideally I could specify a fairly robust markup language for describing context and relationships between thoughts, and then fine-tune models to understand the syntax. More on it later.</p>
<p>Anyway, the endpoint is kinda done but I broke the fuck out of the embedding system so all of comind is broken&#33; Living the dream.</p>
<h2 id="graph_database_work">graph database work</h2>
<p>I also fucked around with graph databases. Today&#39;s thing was to see how binary representations of entities, relationships, and properties work.</p>
<p>To rephrase – how the fuck do you actually store a node on disk in an efficient way? Neo4j stores nodes as fixed-length 15 byte chunks:</p>
<ul>
<li><p>The first byte checks whether the record is in use or can be re-used. Apparently this is called a &quot;tombstone&quot;, thanks to my brother Q for the tip.</p>
</li>
<li><p>The next four bytes contain the ID of the first relationship connected to the node.</p>
</li>
<li><p>The following four contain the ID of the first property connected to the node.</p>
</li>
<li><p>Five store labels references &#40;i.e. Person, or Car&#41;, but they can be inlined apparently if there&#39;s a small number.</p>
</li>
<li><p>Final byte reserved for some future use.</p>
</li>
</ul>
<p>I wanted to play around with this, so I wrote some code. My graph specification only has nodes for now, but I&#39;ve made a few alternative choices:</p>
<ol>
<li><p>A tombstone byte.</p>
</li>
<li><p>An N-byte ID for the node.</p>
</li>
<li><p>An N-byte ID for the relationship splay tree. </p>
</li>
<li><p>An N-byte ID for the property splay tree.</p>
</li>
<li><p>An N-byte ID for the location of the node&#39;s embedding vector, or a pointer to the splay tree if different embedding models are used.</p>
</li>
</ol>
<p>IDs 3-5 are &quot;pointers&quot; in that they refer to positions in storage files containing another fixed-length record. More on the splay trees later, haven&#39;t figured them out yet.</p>
<p>N here is probably 128, which is big, but I&#39;m still trying to figure out how you support ordered records that are compact and easy to handle in a distributed format. I settled on ULIDs, which are 128-bit and hardened to prevent collisions across distributed systems. </p>
<p>Here&#39;s how you specify the format of the storage system.</p>
<ul>
<li><p><code>ID_TYPE</code> is the type of the ID – how many bytes it takes to represent the ID. Here it&#39;s a 2-byte ID.</p>
</li>
<li><p><code>ID_SIZE_BYTES</code> is the number of bytes in the ID.</p>
</li>
<li><p><code>NODE_RECORD_SIZE</code> is the number of bytes in the node record – four IDs and a tombstone byte.</p>
</li>
<li><p><code>BLOCK_SIZE</code> is the number of records per partition file. A partition file is just a file on disk with the format <code>node.&#91;partition&#93;.dat</code>.</p>
</li>
</ul>
<pre><code class="language-julia">const ID_TYPE &#61; UInt16
const ID_SIZE_BYTES &#61; sizeof&#40;ID_TYPE&#41;
const NODE_RECORD_SIZE &#61; 1 &#43; ID_SIZE_BYTES * 4
const BLOCK_SIZE &#61; 2 # Records per partition file</code></pre>
<p>In a simpler version of this, say where we only have 1-bit IDs and a block size of 2, then the binary representation of each partition file looks like</p>
<pre><code class="language-julia">10000 # First record, tombstone is set
00000 # Second record, tombstone is not set</code></pre>
<p>and so on.</p>
<p>Anyway. Now we need to do some byte representation stuff. Most of the shit on your machine is bytes and thus so is the code, and working with raw bits and casting up to <code>UInt128</code> or whatever all the time sucks. So I made <code>ByteArray</code>, which just wraps around a <code>Vector&#123;UInt8&#125;</code> and lets you treat it like a standard array but supports offset indexing.</p>
<pre><code class="language-julia">struct ByteArray
    bits::Vector&#123;UInt8&#125;
end# Standard interface implementations
Base.length&#40;b::ByteArray&#41; &#61; length&#40;b.bits&#41; * 8
Base.firstindex&#40;b::ByteArray&#41; &#61; 1
Base.lastindex&#40;b::ByteArray&#41; &#61; length&#40;b.bits&#41; * 8
Base.getindex&#40;b::ByteArray, i::Int&#41; &#61; b.bits&#91;8i-1:8i&#93;
Base.setindex&#40;b::ByteArray, v::Vector&#123;UInt8&#125;, i::Int&#41; &#61; b.bits&#91;8i-1:8i&#93; &#61; v</code></pre>
<p>We now need to be able to convert an array of bytes to whatever the root ID type is, and vice versa. For example,  if I have a <code>UInt16</code> ID type, then I need to be able to convert to <code>UInt8</code> values into a <code>UInt16</code> ID.</p>
<pre><code class="language-julia">id2bytes&#40;x&#41; &#61; reinterpret&#40;UInt8, &#91;x&#93;&#41;
bytes2id&#40;x&#41; &#61; reinterpret&#40;ID_TYPE, x&#41; |&gt; only # TODO not clear on why this returns a single vector</code></pre>
<p>The <code>ByteVector</code> representation of an ID is just a vector of bytes, like so:</p>
<pre><code class="language-julia">2-element Vector&#123;UInt8&#125;:
 0x41
 0x3b</code></pre>
<p>but converts to the <code>UInt16</code> ID type when you use <code>bytes2id</code>:</p>
<pre><code class="language-julia">0x3b41</code></pre>
<p>Let&#39;s bundle these up into a node record, which stores all the different IDs it tracks, as well as some constructors.</p>
<pre><code class="language-julia">struct NodeRecord&#123;BV&#125;
    tombstone::UInt8
    id::BV
    relationships::BV
    properties::BV
    vector::BV
endfunction NodeRecord&#40;tombstone::Bool, id, relationships, properties, vector&#41;
    NodeRecord&#40;tombstone, id2bytes&#40;id&#41;, id2bytes&#40;relationships&#41;, id2bytes&#40;properties&#41;, id2bytes&#40;vector&#41;&#41;
endfunction NodeRecord&#40;bytes::Vector&#123;UInt8&#125;&#41;
    tombstone &#61; bytes&#91;1&#93;
    id &#61; bytes&#91;2&#93;
    relationships &#61; bytes&#91;3&#93;
    properties &#61; bytes&#91;4&#93;
    vector &#61; bytes&#91;5&#93;
    NodeRecord&#40;tombstone, id, relationships, properties, vector&#41;
end</code></pre>
<p>We know which partition file the record belongs to by it&#39;s ID. Only <code>BLOCK_SIZE</code> records are stored in a partition file, and the IDs of the records in the file are sequential. If we have IDs 1,2,3, and 4 and a block size of 2, then 1 and 2 would be in partition 1, 3 and 4 would be in partition 2. </p>
<p><code>whichpartition</code> is a function that takes an ID and returns the partition file it belongs to.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    whichpartition&#40;id&#41;Determine which partition file a given ID belongs to. Partitions are of size BLOCK_SIZE nodes.
An ID of 1 through BLOCK_SIZE belongs to partition 1, BLOCK_SIZE&#43;1 through 2*BLOCK_SIZE belongs to partition 2, etc.
&quot;&quot;&quot;
function whichpartition&#40;byteid&#41;
    return div&#40;bytes2id&#40;byteid&#41; - 1, BLOCK_SIZE&#41; &#43; 1
end# Also get the name of the file we&#39;ll write/read to.
datafile&#40;n::NodeRecord&#41; &#61; &quot;node.&#36;&#40;whichpartition&#40;n.id&#41;&#41;.dat&quot;</code></pre>
<p>We also know that, within a binary file, we can skip ahead to where the record is if we know its ID. <code>recordstart</code> is a function that takes an ID and returns the start of the record <em>within</em> a partition file. In the above example, if I have a record with ID 3, then the record starts at the 6th byte of the file if records are five-bytes long. The whole file is 12 bytes.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    recordstart&#40;id&#41;Determine the start of a record within a partition file. Records are of size NODE_RECORD_SIZE,
so a record starts at a multiple of NODE_RECORD_SIZE. 
&quot;&quot;&quot;
function recordstart&#40;byteid&#41;
    return mod&#40;bytes2id&#40;byteid&#41; - 1, BLOCK_SIZE&#41; * NODE_RECORD_SIZE
end</code></pre>
<p>Next we want to convert a <code>NodeRecord</code> to a byte array so we can write it to disk.</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    bytes&#40;id&#41;Node storage contains a leading byte indicating whether the node is active.
It is followed by the 128-bit node ID.
Then are 128-bit IDs for each of the relationship, properties, and vector files.&#96;bytes&#96; converts a &#96;NodeRecord&#96; to a byte array.
&quot;&quot;&quot;
function bytes&#40;n::NodeRecord&#41;
    return vcat&#40;
        UInt8&#40;n.tombstone&#41;,
        n.id,
        n.relationships,
        n.properties,
        n.vector
    &#41;
end</code></pre>
<p>This gets used here, where we write a <code>NodeRecord</code> to the partition file it belongs to:</p>
<pre><code class="language-julia">function save&#40;n::NodeRecord&#41;
    # Get the partition file
    partition &#61; whichpartition&#40;n.id&#41;
    filename &#61; datafile&#40;n&#41;    # If the partition file does not exist, create it. Fill the whole BLOCK_SIZE
    # with zeros to make the file size a multiple of BLOCK_SIZE.
    if &#33;isfile&#40;filename&#41;
        open&#40;filename, &quot;w&quot;&#41; do f
            write&#40;f, zeros&#40;UInt8, NODE_RECORD_SIZE * BLOCK_SIZE&#41;&#41;
        end
    else
        # Check that the partition file is of the correct size
        if filesize&#40;filename&#41; &#33;&#61; NODE_RECORD_SIZE * BLOCK_SIZE
            @error &quot;Partition file is not the correct size&quot; filename filesize&#40;filename&#41; NODE_RECORD_SIZE * BLOCK_SIZE
        end
    end    # Write the record
    open&#40;filename, append&#61;true&#41; do f
        seek&#40;f, recordstart&#40;n.id&#41;&#41;
        write&#40;f, bytes&#40;n&#41;&#41;
    end
end</code></pre>
<p>To unpack this briefly:</p>
<ol>
<li><p>Get the partition file to write to.</p>
</li>
<li><p>If the partition file does not exist, create it. Fill the whole <code>BLOCK_SIZE</code> with zeros to make the file size a multiple of <code>BLOCK_SIZE</code>.</p>
</li>
<li><p>Write the record to the partition file at its location &#40;we go to the record start spot using <code>seek</code>&#41;.</p>
</li>
</ol>
<p>Then, lastly, we can load the record back using</p>
<pre><code class="language-julia">&quot;&quot;&quot;
    node_record&#40;id&#41;Load a &#96;NodeRecord&#96; from the file system.
&quot;&quot;&quot;
function node_record&#40;id&#41;
    partition &#61; whichpartition&#40;id&#41;
    filename &#61; &quot;node.&#36;partition.dat&quot;
    open&#40;filename, &quot;r&quot;&#41; do f
        seek&#40;f, recordstart&#40;id&#41;&#41;
        read&#40;f, NODE_RECORD_SIZE&#41;
    end
end</code></pre>
<p>Voila&#33;</p>
<p>Now, the following works:</p>
<pre><code class="language-julia">julia&gt; id1 &#61; rand&#40;UInt8, ID_SIZE_BYTES&#41;
2-element Vector&#123;UInt8&#125;:
 0x63
 0xadjulia&gt; id2 &#61; rand&#40;UInt8, ID_SIZE_BYTES&#41;
2-element Vector&#123;UInt8&#125;:
 0x7a
 0x67julia&gt; id3 &#61; rand&#40;UInt8, ID_SIZE_BYTES&#41;
2-element Vector&#123;UInt8&#125;:
 0x9f
 0xd2julia&gt; id4 &#61; rand&#40;UInt8, ID_SIZE_BYTES&#41;
2-element Vector&#123;UInt8&#125;:
 0xf0
 0xabjulia&gt; record &#61; NodeRecord&#40;UInt8&#40;1&#41;, id1, id2, id3, id4&#41;
NodeRecord&#123;Vector&#123;UInt8&#125;&#125;&#40;0x01, UInt8&#91;0x63, 0xad&#93;, UInt8&#91;0x7a, 0x67&#93;, UInt8&#91;0x9f, 0xd2&#93;, UInt8&#91;0xf0, 0xab&#93;&#41;julia&gt; record_bytes &#61; bytes&#40;record&#41;
9-element Vector&#123;UInt8&#125;:
 0x01
 0x63
 0xad
 0x7a
 0x67
 0x9f
 0xd2
 0xf0
 0xabjulia&gt; whichpartition&#40;id1&#41;
22194julia&gt; recordstart&#40;id1&#41;
0julia&gt; save&#40;record&#41;
9julia&gt; @test node_record&#40;id1&#41; &#61;&#61; record_bytes
Test Passed</code></pre>
<p>Cool. Nailed it. More to do here, excited to get into some more interesting relationship/property stuff&#33;</p>
<p>– Cameron</p>
 ]]>
  </content:encoded>
    
  <pubDate>Sat, 04 May 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>mindco</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  devlog 2024-05-03  ]]>
  </title>
  <link> https://blog.comind.me/devlogs/2024-05-03/index.html </link>
  <guid> https://blog.comind.me/devlogs/2024-05-03/index.html </guid>
  <description>
    <![CDATA[  some stuff about melds and how they work in comind  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="devlog_2024-05-03">devlog 2024-05-03</h1>
<ul>
<li><p>Fixed some bugs on the front end, where the websocket container was closing prematurely. This ended up being an issue with what I was putting into the <a href="https://react.dev/reference/react/useEffect#examples-dependencies">dependency array</a>, which determines when something is to be rendered. I had placed an array of thoughts in the dependency array, and the websocket modifies those thoughts, which causes the component to rerender. This is kind of an issue, because I basically just duct-taped it together. The full Next build will fail because of this, currently, but dev mode works fine &#40;for now&#41;.</p>
<ul>
<li><p>The front end is still not available, largely because the release builds won&#39;t work without me addressing a litany of stupid shit I&#39;ve done.</p>
</li>
</ul>
</li>
<li><p>Updated the meld view. The meld view lists all melds that you have or are a part of. You can now make a new one with a title and a description, refresh the list, and click into the meld &#40;&quot;jump in&quot;&#41; to see the thoughts.</p>
<ul>
<li><p>Unfortunately the &quot;jump in&quot; button does not let you jump in, maybe more like &quot;get a 404&quot;. Basically, I produce slugs &#40;<code>/meld/&lt;slug&gt;</code>&#41; for melds. The backend assigns slugs asynchronously, so the front end has no idea where the button is supposed to point to, i.e. <code>meld/null</code>.</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://blog.comind.me/assets/2024-05-03/a.png" alt="A display of the meld view" /></p>
<ul>
<li><p>The frontend framework I chose, <a href="https://mantine.dev/">Matine</a>, is extremely good. There&#39;s a lot fewer degrees of freedom than in <a href="https://tailwindcss.com/">Tailwind</a>, my previous framework. It has really helped me speed through creating bits and pieces without this crazy-ass web of <code>div</code>s and <code>className</code>s. It is, however, not <em>quite</em> what I want stylistically, but I&#39;ve decided I just need to get some shit out the door and I don&#39;t really care too much about how it looks.</p>
<ul>
<li><p>There will be a frontend redesign at some point to accomodate Android &#43; iOS, so this will be a natural time to revisit the entire look and feel of the app.</p>
</li>
</ul>
</li>
<li><p>Spent a little bit of time trying to set up Neo4j, the graph database I am considering migrating to. Friend of the comind <a href="https://twitter.com/MasonRHayes">Mason</a> found a Neo4j <a href="https://gitlab.com/plantingspace/neo4jbase.jl">connector package</a> written by Julia friendos at <a href="https://planting.space/">PlantingSpace</a>.</p>
<ul>
<li><p>Thanks Mason for tracking that down&#33;</p>
</li>
<li><p>PlantingSpace is a cool-ass company.</p>
</li>
<li><p>Got the docker container working. </p>
</li>
</ul>
</li>
<li><p>Played with some visuals. One of my favorite things about comind is that it is kind of an art project, so intermittently I let myself be distracted and just kind of make things I think are pretty. In this case, I made the loading screen, which has this kind of chill, plain, adult-swim-y vibe to it. My goal has always been to try to capture that simple Adult Swim vibe and I&#39;m not sure if this quite does it, but I like it for now.</p>
</li>
</ul>
<p><img src="https://blog.comind.me/assets/2024-05-03/b.png" alt="A comind is thinking page" /></p>
<p>To bed now.</p>
<p>– Cameron Pfiffer</p>
 ]]>
  </content:encoded>
    
  <pubDate>Fri, 03 May 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>mindco</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  devlog 2024-04-29, web stuff &amp; melds  ]]>
  </title>
  <link> https://blog.comind.me/devlogs/2024-04-29/index.html </link>
  <guid> https://blog.comind.me/devlogs/2024-04-29/index.html </guid>
  <description>
    <![CDATA[  some stuff about melds and how they work in comind  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  <h1 id="devlog_2024-04-29_web_stuff_melds">devlog 2024-04-29, web stuff &amp; melds</h1>
<p>More today on the ongoing construction of Welder.jl, &#123;comind&#125;&#39;s websocket server for handling melds.  Melds are something like forums, group chats, or twitter threads – you and/or a group of people can chat about a topic in real time. Each of you will be shown suggested thoughts any time a new thought is added to the meld. </p>
<p><strong>Suggestions</strong> are thoughts that </p>
<ul>
<li><p>you or someone else has written before</p>
</li>
<li><p>previously linked to the previous note</p>
</li>
<li><p>language model generated commentary like summaries or direct answers to questions</p>
</li>
<li><p>suggestions to view other melds</p>
</li>
<li><p>offers or tips to use a particular feature</p>
</li>
</ul>
<p>The idea here is that you type your way around comind, sometimes just thinking to yourself,  in public melds, small group melds, business melds, etc. When you think, you either add something to a stream of conciousness yourself, or you pull in a suggestion. </p>
<p>While you type your way along, you can also choose to be &quot;pulled&quot; around by accepting suggestions. These are the main feature of comind. You should think of suggestions as thoughts that change, interpret, or assist you in whatever you are thinking about. </p>
<p>For example, if you are in a meld for a research group, you might be shown suggestions like</p>
<ul>
<li><p>This paper seems to be related to what you and your group are discussing, and it may be helpful to note X and Y.</p>
</li>
<li><p>A reminder that you seem to have written something related elsewhere, like in an email or other meld.</p>
</li>
<li><p>A link to a meld where you and a friend were discussing a paper. This shares the dialog from a meld with the meld you add it to.</p>
</li>
<li><p>Any of the &#123;comind&#125; language models. </p>
<ul>
<li><p>&#123;co&#125; &#40;the &quot;main&quot; language model&#41; has access to your complete knowledge graph to the accept you permit it, and will act as something like a personal search and query engine in response to thoughts that resemble queries.</p>
</li>
<li><p>&#123;science&#125;, the comind for the concept &quot;science&quot;, may provide an overview of the current discussion of your paper in all other public melds.</p>
</li>
<li><p>&#123;void&#125; might just say &quot;you should toss that to the void. i&#39;d love to read it.&quot; You could probably turn these off if you wanted.</p>
</li>
</ul>
</li>
</ul>
<p>All this is hard to do, technically. I&#39;ve discussed this before but it bears repeating. I&#39;m spending a <em>lot</em> of time on Welder.jl, in part because it&#39;s one of the more important pieces of &#123;comind&#125;&#39;s infrastructure.</p>
<p>Some accomplishments:</p>
<ul>
<li><p>Thoughts sent to the websocket server are now relayed to the main server, so they are persistent now.</p>
</li>
<li><p>Each new thought in a meld is linked to the one before it, this now works client -&gt; welder -&gt; server -&gt; database.</p>
</li>
<li><p>The root weld &#40;no other meld&#41; now works, and you can also call up a meld by its slug. <code>/meld/the-have</code> is my testing example.</p>
</li>
<li><p>Produced a simple, interactive client for testing a meld.</p>
</li>
<li><p>Supported a simple suggestion relay to the user.</p>
</li>
</ul>
<p>Basically, I can talk to myself now, real time, and the server is now sending me &#40;very dumb&#41; suggestions about what I should look at next. </p>
<p>I also have a working pseudo-REPL terminal UI to use when I do meld work. Welder.jl is a much higher quality project than my usual fare, and I&#39;m really happy with both the test scaffolding and the project thusfar.</p>
<p>Here&#39;s an example of the suggestions I got, sourced only by semantic search:</p>
<pre><code class="language-julia">cameron, 2024-02-21T15:55:47.846
╭──────────────────────────────────────────────────────────────────────────────────────╮
│  And look at that&#33; It works now. It&#39;s worth talking about why I think there should   │
│   be thought titles on here. In some sense this is kind of a tweet-place, where      │
│  users write lots of short-form stuff.                                               │
│                                                                                      │
│  1. We don&#39;t _usually_ have titles for this kinds of things, because the posts       │
│  are so short. On Comind, I don&#39;t actually restrict length to anything &#40;though       │
│  I may at some point for RAG purposes&#41;, so it kind of helps to be able to get        │
│  a rough description of what&#39;s in the thought for those longer documents.            │
│  2. It&#39;s goofy. I like having kinda dumb default titles. I&#39;m always looking for      │
│  ways to make comind an interesting place for play and silly LLM applications,       │
│  and titles seemed relatively obvious &#40;ChatGPT, for example, does this quite         │
│  well&#41;.                                                                              │
│  3. It helps you find stuff. Comind is fundamentally a notetaking and knowledge      │
│  graph tool, and so we want to provide tools that make it easy to determine what     │
│  is inside a given thought.                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────╯cameron, 2024-02-12T18:41:32.651
╭──────────────────────────────────────────────────────────────────────────────────────╮
│  &#40;side note for #comind-ui, the tabula rasa baybee placeholder should say &quot;add       │
│  more thoughts&quot; when the top of mind is populated&#41;                                   │
╰──────────────────────────────────────────────────────────────────────────────────────╯test, 2024-03-27T06:13:00.526
╭──────────────────────────────────────────────────────────────────────────────────────╮
│  This is a test thought, from a testy fella                                          │
╰──────────────────────────────────────────────────────────────────────────────────────╯</code></pre>
<p>Good fuckin&#39; day in my opinion.</p>
<p>– Cameron</p>
 ]]>
  </content:encoded>
    
  <pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>mindco</atom:name>
  </atom:author>
        
</item>
</channel></rss>